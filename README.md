# ifs

A package for generating IFS fractals.

## Installation

## Theory

This isn't the "official" theory of IFS systems. I'm not a mathematician, I'm a cognitive science undergraduate student. Accordingly, the stuff here is a mix of stuff that I read, stuff from videos I watched, and stuff I literally just made up. Accordingly, take it with a grain (or perhaps a tablespoon) of salt.

An IFS consists of several components:

* a set of verticies in n dimensions
* a function that accepts two points from n dimensional space, along with several parameters
* a ruleset for the application of the function
* some arbitrary starting point
  + question: can the starting point always be arbitrary? I would intuitively think so, given the prespecified convergent-function criteria. On the other hand, there may be functions for which some areas of the space are convergent, or bounded, and other areas of the space diverge, in which case the starting point would not be arbitrary.

## Notes

* Investigate a novel class of fractals generated by iterated function systems
* Demonstrate functions that can generate previously unknown fractals
* Show how seemingly disparate combinations of rules and functions as inputs can converge to similar, or in some cases the same fractals.
* Generator function needs to test convergence - functions must be convergent in order for there to be potential for a fractal to form.
  + question: if a function is convergent along a one dimensional axis, is it also convergent in all higher dimensions?

## Ideas

* What if the parameters of the midpoint/ruleset functions passed in dynamically adjusted themselves based on the points?
* Is it possible to create some kind of evolutionary algorithm which allows you to converge towards IFS systems that generate any sort of structure?
  + If this is the case, then could you use this as a form of compression? Instead of actually storing a 3D object, for instance, could you just store the parameters required to generate the 3D object? If you could, that would be an extremely useful tool for compression.
  + TODO: If ^this is the case, and I can actually do this, then I should not just write a blog post, but I should also compile this into a basic publication and post it on arxiv, as well as restructuring the codebase to make it pip installable, and more accessible to a greater variety of people.
    - I would also probably want to rewrite most of it in rust to speed up the execution and generation. This would be a good excuse to finally learn rust, and a great project to learn it with.

## Notes to sort

For instance, take the archetypal Sierpinski chaos game.
In this game we have n+1 vertices in an n dimensional space, where our vertices are not collinear and n is greater than or equal to two. For instance – three vertices forming an equilateral triangle on a two-dimensional plane.
In the game, our function f takes in two points A and B, each represented as one dimensional matrices where the length of the matrix denotes the dimension of the space the point is placed in, and outputs the coordinates of the point that is exactly half way between the two input points.
The ruleset for the
does the function blow up to infinity - iteratively run, check distance from origin and graph for each step, run may simulations and graph

CONCLUSION
Historically, different fractal permutations have been generated by modifying the set of vertices, and the ruleset for the application of the function, but the same function – one that takes in point A and B and parameter d (for the distance between the two points), has always been used. In this paper we show that by modifying the function in the synthesis of the iterated function system, we can generate novel fractals, or in some cases come upon the same fractals we have seen before, though we reached them through wildly different rulesets and functions.
More research is needed into the nature of the state space representing the potential combinations of rulesets, functions, and vertices, the locations on that states space that converge to form fractals, and the relation between the locations on the state space that form the same or similar fractals. Also, the use of novel functions to generate different and unseen fractals
For fractals, perhaps use Bezier curves as midpoint functions?

    # for any non-animated visualizations
    # - 1D (histogram)
    # - 2D (2D scatterplot, 1D histogram as slice)
    # - 3D (3D scatterplot, 2D scatterplot + color, 2D scatterplot + size, 2D scatterplot as slice, 1D histogram + color as slice)
    # - 4D (3D scatterplot + color, 3D scatterplot + size, 3D scatterplot as slice, 2D scatterplot + color + size, 2D)
    # - 5D (3D scatterplot + color + size, 3D scatterplot + color + slice, 3D scatterplot + size + slice)

Needs to be able to take in some function

requires the current point, also the selected edge, and also some set of parameters

I should be able to use sympy to resolve the function, which will help for evolutionary search.

* must always have parameters A and B, can have any other number of parameters
* must be valid mathematical operation
# Types
* main inputs
* variable parameters (can set)
* constants

### Operators

* addition (must be length 2 values)
* subtraction (must be length 2 values)
* multiplication (must be length 2 values)
* division (must be length 2 values)
* powers (must be length 2 values)
  + implicitly covers square roots (powers where in $m^n$, n = [0, 1])
* logarithms (must be length 2 values)
* sin, cos, tan (must be length 1 values)

### Steps

1. First, decide on how many parameters will go into the function.
# need to be able to take a bunch of variables, and generate a random

# function with them

# Function Components

# select some number of variables with some probability

# select an operation to apply to them (must be valid operation)

# Component Combination

# ? need to be able to combine the generated functions into a valid output

# ! how does the "flavor" of IFS generated change with the change in generator

# ! function parameters?

# ! how do we integrate the capacity for small modifications into the generators

# ! so that an evolutionary search can be done?
