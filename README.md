# ifs

A package for generating IFS fractals.

## Installation

## Theory

This isn't the "official" theory of IFS systems. I'm not a mathematician, I'm a cognitive science undergraduate student. Accordingly, the stuff here is a mix of stuff that I read, stuff from videos I watched, and stuff I literally just made up. Accordingly, take it with a grain of salt.

An IFS consists of several components:

* a set of verticies in n dimensions
* a function that accepts two points from n dimensional space, along with several parameters
* a ruleset for the application of the function
* some arbitrary starting point
  + question: can the starting point always be arbitrary? I would intuitively think so, given the prespecified convergent-function criteria. On the other hand, there may be functions for which some areas of the space are convergent, or bounded, and other areas of the space diverge, in which case the starting point would not be arbitrary.

## Notes

* Investigate a novel class of fractals generated by iterated function systems
* Demonstrate functions that can generate previously unknown fractals
* Show how seemingly disparate combinations of rules and functions as inputs can converge to similar, or in some cases the same fractals.
* Generator function needs to test convergence - functions must be convergent in order for there to be potential for a fractal to form.
  + question: if a function is convergent along a one dimensional axis, is it also convergent in all higher dimensions?

## Ideas

* What if the parameters of the midpoint/ruleset functions passed in dynamically adjusted themselves based on the points?
* Is it possible to create some kind of evolutionary algorithm which allows you to converge towards IFS systems that generate any sort of structure?
  + If this is the case, then could you use this as a form of compression? Instead of actually storing a 3D object, for instance, could you just store the parameters required to generate the 3D object? If you could, that would be an extremely useful tool for compression.

## Notes to sort

For instance, take the archetypal Sierpinski chaos game.
In this game we have n+1 vertices in an n dimensional space, where our vertices are not collinear and n is greater than or equal to two. For instance – three vertices forming an equilateral triangle on a two-dimensional plane.
In the game, our function f takes in two points A and B, each represented as one dimensional matrices where the length of the matrix denotes the dimension of the space the point is placed in, and outputs the coordinates of the point that is exactly half way between the two input points.
The ruleset for the
does the function blow up to infinity - iteratively run, check distance from origin and graph for each step, run may simulations and graph

CONCLUSION
Historically, different fractal permutations have been generated by modifying the set of vertices, and the ruleset for the application of the function, but the same function – one that takes in point A and B and parameter d (for the distance between the two points), has always been used. In this paper we show that by modifying the function in the synthesis of the iterated function system, we can generate novel fractals, or in some cases come upon the same fractals we have seen before, though we reached them through wildly different rulesets and functions.
More research is needed into the nature of the state space representing the potential combinations of rulesets, functions, and vertices, the locations on that states space that converge to form fractals, and the relation between the locations on the state space that form the same or similar fractals. Also, the use of novel functions to generate different and unseen fractals
For fractals, perhaps use Bezier curves as midpoint functions?
